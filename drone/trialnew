using Dojo
using DojoEnvironments
using LinearAlgebra

# ### Environment
quadrotor_env = get_environment(:quadrotor_waypoint; horizon=1000)

# ### Waypoints
waypoints = [[0.0, 0.0, 0.8], [1.0, 0.0, 0.8], [1.0, 1.0, 0.8], [0.0, 1.0, 0.8]]

# ### Controllers
current_waypoint_index = 1

function attitude_controller!(environment, orientation_des)
    state = get_state(environment)
    orientation = state[4:6] # axis*angle
    angular_velocity = state[10:12] # ωx, ωy, ωz 
    
    error_orientation = orientation_des .- orientation
    torque = (10 .* error_orientation .- 1 .* angular_velocity) # P, D gains

    set_torque!(environment, torque)
end

function velocity_controller!(environment, v_des)
    state = get_state(environment)
    position = state[1:3] # x, y, z
    orientation = state[4:6] # axis*angle
    linear_velocity = state[7:9] # vx, vy, vz
    angular_velocity = state[10:12] # ωx, ωy, ωz 

    v_is = state[7:9]
    error_v = v_des .- v_is

    thrust = (10 .* error_v .- 1 .* v_is .+ 5.1) # P, D, feedforward

    # Create a 4-element thrust vector for each rotor
    rpm = thrust[3] .* ones(4)
    set_input!(environment, rpm)
end

function position_controller!(environment, pos_des)
    state = get_state(environment)
    pos_is = state[1:3] # x, y, z
    
    v_des = pos_des .- pos_is
    velocity_controller!(environment, v_des)
end

function controller!(environment, k)
    global current_waypoint_index
    if current_waypoint_index > length(waypoints)
        return
    end
    
    waypoint = waypoints[current_waypoint_index]
    position_controller!(environment, waypoint)
    
    state = get_state(environment)
    pos_is = state[1:3]
    if norm(waypoint .- pos_is) < 0.1
        current_waypoint_index += 1
    end
end

# ### Simulate
initialize!(quadrotor_env, :quadrotor)
simulate!(quadrotor_env, controller!; record=true)

# ### Visualize
vis = visualize(quadrotor_env)
render(vis)
